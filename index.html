<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stillnight: Eve of the Stack</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Share+Tech+Mono&display=swap');

        :root {
            --pe-dark: #050505;
            --pe-panel-bg: linear-gradient(180deg, #1a1a1a 0%, #080808 100%);
            --pe-teal-header: linear-gradient(90deg, #004d4d, #000); 
            --pe-gold: #fbbf24;
            --pe-text-gray: #9ca3af;
            --pe-green: #10b981;
            --pe-red: #ef4444;
            --pe-cyan: #00ffff;
            --font-ui: 'Share Tech Mono', monospace;
        }

        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: var(--font-ui);
            user-select: none;
            color: var(--pe-text-gray);
            cursor: default;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #app-container {
            width: 960px;
            height: 540px;
            position: relative;
            background: black;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        #screen-fx {
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle, transparent 50%, black 120%),
                linear-gradient(rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.2) 50%);
            background-size: 100% 100%, 100% 4px;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.6;
            mix-blend-mode: overlay;
        }

        /* --- UI SYSTEM --- */
        .pe-window {
            position: absolute;
            background: var(--pe-panel-bg);
            border: 1px solid #444;
            box-shadow: 0 0 10px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 2px;
            pointer-events: auto;
        }

        .pe-header {
            background: var(--pe-teal-header);
            color: white;
            font-size: 12px;
            padding: 2px 8px;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-bottom: 1px solid #000;
            text-shadow: 1px 1px 0 #000;
        }

        .pe-content {
            flex: 1;
            padding: 6px;
            overflow: hidden; 
            font-size: 12px;
        }
        
        .pe-content::-webkit-scrollbar { width: 4px; }
        .pe-content::-webkit-scrollbar-thumb { background: var(--pe-gold); }

        #floating-text-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 50;
        }
        
        .float-text-container {
            position: absolute;
            display: flex;
            gap: 1px;
            pointer-events: none;
        }
        
        .float-digit {
            font-weight: bold;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            color: white;
            display: inline-block;
            opacity: 0;
            animation: bounce-digit 0.8s forwards cubic-bezier(0.25, 1, 0.5, 1);
        }

        @keyframes bounce-digit {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            30% { transform: translateY(-30px) scale(1.4); opacity: 1; }
            60% { transform: translateY(0) scale(1); }
            85% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-10px) scale(1); opacity: 0; }
        }

        .item-row {
            padding: 4px 6px;
            cursor: pointer;
            border: 1px solid transparent;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.3);
            margin-bottom: 2px;
        }
        .item-row:hover {
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--pe-gold);
            color: white;
        }

        .party-slot {
            display: flex; gap: 4px; margin-bottom: 6px; padding: 4px;
            border: 1px solid #333; transition: all 0.2s;
            background: rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .party-slot:hover {
            background: rgba(255,255,255,0.05);
            border-color: #666;
        }
        .party-slot.active {
            border-color: var(--pe-gold);
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.1), transparent);
            transform: translateX(4px);
        }

        .cmd-btn {
            padding: 8px; margin-bottom: 4px;
            cursor: pointer; color: #aaa; border-left: 3px solid transparent;
            background: rgba(0,0,0,0.2);
            display: flex; justify-content: space-between;
            align-items: center;
        }
        .cmd-btn:hover { background: #222; color: #fff; border-left-color: var(--pe-gold); }
        .cmd-btn.disabled { opacity: 0.5; pointer-events: none; border-left-color: #333; }

        .stat-label { color: var(--pe-gold); font-weight: bold; }
        .stat-val { color: white; float: right; }

        #tooltip {
            position: absolute; pointer-events: none; 
            background: rgba(0,0,0,0.9); border: 1px solid var(--pe-gold);
            padding: 8px; z-index: 100; display: none; max-width: 200px;
            font-size: 11px; box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
        }

        #cutscene-overlay {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            width: 50%; background: rgba(0,0,0,0.9); border: 1px solid #555;
            padding: 15px; color: white; display: none; text-align: center;
            font-family: var(--font-ui); z-index: 200;
            box-shadow: 0 0 20px rgba(0,255,255,0.1);
        }

        #game-canvas { width: 100%; height: 100%; image-rendering: pixelated; }
        
        #minimap-canvas { image-rendering: pixelated; background: #000; }
    </style>
</head>
<body>

<div id="app-container">
    <div id="screen-fx"></div>
    <div id="ui-root" class="w-full h-full relative">
        <div id="floating-text-layer"></div>
        <div id="cutscene-overlay"></div>
        <div id="tooltip"></div>
    </div>
</div>

<script>
/**
 * STILLNIGHT: EVE OF THE STACK (V10.3 - SEAMLESS & DRAMATIC)
 */

// ============================================================================
// [1] DATA
// ============================================================================
/**
 * Configuration for game colors.
 * @constant
 * @type {Object}
 */
const CONFIG = { colors: { floor: 0x333333, wall: 0x1a1a1a, fog: 0x051015, bg: 0x050510 } };

const TRAIT_PARAM_PLUS = 1;
const TRAIT_PARAM_RATE = 2;
const TRAIT_RESTRICTION = 3;
const TRAIT_ATTACK_SKILL = 4;

const PARAM_MHP = 0;
const PARAM_MPE = 1;
const PARAM_ATK = 2;
const PARAM_DEF = 3;

const $dataStates = {
    "barrier": { name: "Barrier", duration: 4, icon: "üõ°Ô∏è", traits: [{ code: TRAIT_PARAM_PLUS, dataId: PARAM_DEF, value: 2 }] },
    "stun": { name: "Stunned", duration: 2, icon: "‚ö°", traits: [{ code: TRAIT_RESTRICTION, dataId: 0, value: 0 }] },
    "poison": { name: "Poison", duration: 5, icon: "‚ò†Ô∏è", traits: [] }
};

/**
 * Data definitions for all available skills.
 * @constant
 * @type {Object}
 */
const $dataSkills = {
    "rapid": { name: "Rapid Fire", cost: 10, range: 6, type: "target", power: 1.2, count: 2, desc: (a) => `2x shots. Est: ${Math.floor(a.atk * 1.2) * 2} DMG.` },
    "scan": { name: "Scan", cost: 5, range: 0, type: "self", power: 0, desc: () => "Map Intel. Reveals sector layout." },
    "blast": { name: "Grenade", cost: 15, range: 100, type: "all_enemies", power: 15, fixed: true, desc: () => "AoE Blast. 15 DMG to all hostiles." },
    "barrier": { name: "Barrier", cost: 20, range: 0, type: "self", power: 0, desc: () => "Nano-shield. DEF +2 temporarily." },
    "combust": { name: "Combust", cost: 25, range: 100, type: "all_enemies", power: 25, fixed: true, desc: () => "Ignite Room. 25 Fire DMG to all." },
    "drain": { name: "Drain", cost: 10, range: 2, type: "target", power: 10, fixed: true, desc: () => "Bio-leech. 10 DMG + Heal Self." },
    "snipe": { name: "Snipe", cost: 15, range: 8, type: "target", power: 3.0, desc: (a) => `Precision shot. Est: ${Math.floor(a.atk * 3.0)} DMG.` },
    "heal": { name: "Heal", cost: 15, range: 0, type: "self", power: 30, fixed: true, desc: () => "Restore 30 HP." },
    "stun": { name: "Stun Bat", cost: 10, range: 1, type: "target", power: 1.0, desc: (a) => "Melee shock. Chance to stun." },
    "nuke": { name: "Overload", cost: 60, range: 100, type: "all_enemies", power: 60, fixed: true, desc: () => "Discharge all PE. 60 DMG." },
    "gunshot": { name: "Gunshot", cost: 0, range: 5, type: "line", power: 1.5, desc: (a) => `Ranged shot. Est: ${Math.floor(a.atk * 1.5)} DMG.` }
};

/**
 * Data definitions for player classes/characters.
 * @constant
 * @type {Object}
 */
const $dataClasses = {
    "Aya": { job: "Detective", hp: 45, atk: 4, def: 2, pe: 40, color: 0xffff00, skills: ["rapid", "scan", "snipe"] },
    "Kyle": { job: "Trooper", hp: 70, atk: 3, def: 4, pe: 20, color: 0x0088ff, skills: ["blast", "barrier", "stun"] },
    "Eve": { job: "Subject", hp: 35, atk: 6, def: 1, pe: 80, color: 0xff0044, skills: ["combust", "drain", "nuke", "heal"] }
};

/**
 * Data definitions for enemies.
 * @constant
 * @type {Array<Object>}
 */
const $dataEnemies = [
    { id: 1, name: "Sewer Rat", hp: 12, atk: 3, exp: 5, color: 0x885544, scale: 0.4, ai: "hunter" },
    { id: 2, name: "Ooze", hp: 25, atk: 5, exp: 12, color: 0x00ff44, scale: 0.6, ai: "patrol" },
    { id: 3, name: "Stalker", hp: 40, atk: 8, exp: 25, color: 0xff4400, scale: 0.8, ai: "ambush" },
    { id: 4, name: "Watcher", hp: 20, atk: 12, exp: 15, color: 0xaa00ff, scale: 0.5, ai: "turret" },
    { id: 5, name: "Drone", hp: 15, atk: 4, exp: 10, color: 0xaaaaaa, scale: 0.3, ai: "hunter" },
    { id: 6, name: "Mutant Hound", hp: 30, atk: 6, exp: 20, color: 0x880000, scale: 0.5, ai: "hunter" },
    { id: 7, name: "Abomination", hp: 80, atk: 10, exp: 50, color: 0x440044, scale: 1.0, ai: "patrol" }
];

/**
 * Loot table for generating random items.
 * @constant
 * @type {Object}
 */
const $dataLootTable = {
    prefixes: [ { name: "Rusty", atk: -1 }, { name: "Standard", atk: 0 }, { name: "Polished", atk: 1 }, { name: "Violent", atk: 3 }, { name: "Toxic", atk: 2 }, { name: "Ancient", atk: 5 }, { name: "Tech", atk: 2 } ],
    weapons: [ { name: "M92F", baseAtk: 4, icon: "üî´", desc: "Standard issue sidearm.", attackSkill: "gunshot" }, { name: "Tonfa", baseAtk: 3, icon: "‚öîÔ∏è", desc: "Police baton for CQC." }, { name: "Shotgun", baseAtk: 8, icon: "üí•", desc: "High damage, loud noise.", attackSkill: "gunshot" }, { name: "Revolver", baseAtk: 6, icon: "ü§†", desc: "Reliable six-shooter.", attackSkill: "gunshot" }, { name: "Blade", baseAtk: 5, icon: "üó°Ô∏è", desc: "Sharp tactical knife." } ],
    armors: [ { name: "N Vest", baseDef: 2, icon: "ü¶∫", desc: "Basic protection." }, { name: "Kevlar", baseDef: 5, icon: "üõ°Ô∏è", desc: "Ballistic weave vest." }, { name: "Cmbt Suit", baseDef: 8, icon: "üß•", desc: "Full body tactical armor." }, { name: "Tac Gear", baseDef: 6, icon: "ü•ã", desc: "Lightweight ops gear." } ],
    items: [ { name: "Medicine 1", type: "heal", val: 30, icon: "üíä", desc: "Heals 30 HP." }, { name: "Medicine 2", type: "heal", val: 60, icon: "üíâ", desc: "Heals 60 HP." }, { name: "Stim", type: "pe", val: 20, icon: "üß™", desc: "Restores 20 PE." }, { name: "Antidote", type: "cure", val: 0, icon: "üß¨", desc: "Cures poison." } ]
};

/**
 * Configuration for floor generation.
 * @constant
 * @type {Object}
 */
const $dataFloors = {
    1: { width: 30, height: 30, rooms: 12, enemies: 6, loot: 5, cutscene: 'intro' },
    2: { width: 40, height: 40, rooms: 15, enemies: 10, loot: 8 },
    3: { width: 50, height: 50, rooms: 20, enemies: 15, loot: 12 },
    default: { width: 60, height: 60, rooms: 25, enemies: 20, loot: 15 }
};

/**
 * Data for cutscenes.
 * @constant
 * @type {Object}
 */
const $dataCutscenes = {
    'intro': [
        { type: 'wait', time: 500 },
        { type: 'dialog', text: "Target area reached. The stack goes deep.", speaker: "KYLE" },
        { type: 'dialog', text: "My mitochondria... they're screaming.", speaker: "AYA" },
        { type: 'log', text: "Mission Start." }
    ]
};

// ============================================================================
// [2] CORE SYSTEMS
// ============================================================================

/**
 * Manages global game state, such as floor level and logs.
 */
class Game_System {
    /**
     * Creates an instance of Game_System.
     */
    constructor() {
        /**
         * The current floor level.
         * @type {number}
         */
        this.floor = 1;
        /**
         * History of game logs.
         * @type {Array<string>}
         */
        this.logHistory = [];
        /**
         * Indicates if the system is busy processing an action.
         * @type {boolean}
         */
        this.isBusy = false;
        /**
         * Indicates if player input is blocked.
         * @type {boolean}
         */
        this.isInputBlocked = false;
    }

    /**
     * Adds a message to the game log.
     * @param {string} text - The text to log.
     */
    log(text) {
        this.logHistory.unshift(text);
        if(this.logHistory.length > 15) this.logHistory.pop();
        if(typeof UI !== 'undefined' && UI && UI.refreshLog) UI.refreshLog();
    }
}

/**
 * Utility class for sequencing async operations.
 */
class Sequencer {
    /**
     * Pauses execution for a specified duration.
     * @param {number} ms - The number of milliseconds to sleep.
     * @returns {Promise<void>} A promise that resolves after the delay.
     */
    static sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
}

// DEFINED BEFORE USE
/**
 * Represents a generic item in the game.
 */
class Game_Item {
    /**
     * Creates a new Game_Item.
     * @param {Object} d - The data object for the item.
     * @param {string} d.name - The name of the item.
     * @param {string} d.type - The type of the item (e.g., 'heal').
     * @param {number} d.val - The value associated with the item (e.g., heal amount).
     * @param {string} [d.icon] - The icon for the item.
     * @param {string} [d.desc] - The description of the item.
     */
    constructor(d) { this.name = d.name; this.type = d.type; this.val = d.val; this.category = "item"; this.icon = d.icon||"üì¶"; this.desc = d.desc||""; }
}

/**
 * Represents a weapon.
 */
class Game_Weapon {
    /**
     * Creates a new Game_Weapon.
     * @param {Object} b - The base weapon data.
     * @param {Object} p - The prefix data modifying the weapon.
     */
    constructor(b, p) {
        this.name = `${p.name} ${b.name}`;
        this.atk = b.baseAtk + (p.atk||0);
        this.color = p.color;
        this.category = "weapon";
        this.icon = b.icon||"‚öîÔ∏è";
        this.desc = b.desc||"";
        this.traits = [{ code: TRAIT_PARAM_PLUS, dataId: PARAM_ATK, value: this.atk }];
        if (b.attackSkill) this.traits.push({ code: TRAIT_ATTACK_SKILL, dataId: 0, value: b.attackSkill });
    }
}

/**
 * Represents armor.
 */
class Game_Armor {
    /**
     * Creates a new Game_Armor.
     * @param {Object} b - The base armor data.
     */
    constructor(b) {
        this.name = b.name;
        this.def = b.baseDef;
        this.category = "armor";
        this.icon = b.icon||"üõ°Ô∏è";
        this.desc = b.desc||"";
        this.traits = [{ code: TRAIT_PARAM_PLUS, dataId: PARAM_DEF, value: this.def }];
    }
}

/**
 * Represents an enemy in the game.
 */
class Game_Enemy {
    /**
     * Creates a new Game_Enemy.
     * @param {Object} d - The enemy data template.
     * @param {number} x - The x-coordinate on the map.
     * @param {number} y - The y-coordinate on the map.
     * @param {string|number} uid - Unique identifier for the enemy instance.
     * @param {number} hp - The hit points of the enemy.
     */
    constructor(d, x, y, uid, hp) {
        Object.assign(this, d); this.x = x; this.y = y; this.uid = uid; this.hp = hp; this.mhp = hp; this.alerted = false;
        this.def = 0; this.equip = {}; this.states = [];
    }

    takeDamage(v) { this.hp -= v; if(this.hp < 0) this.hp = 0; }

    isDead() { return this.hp <= 0; }

    getAtk() {
        let base = this.atk;
        return Math.floor((base + this.paramPlus(PARAM_ATK)) * this.paramRate(PARAM_ATK));
    }

    getDef() {
        let base = this.def;
        return Math.floor((base + this.paramPlus(PARAM_DEF)) * this.paramRate(PARAM_DEF));
    }

    traitObjects() {
        return [...this.states];
    }

    paramPlus(id) {
        return this.traitObjects().reduce((r, obj) => {
            return r + (obj.traits || []).filter(t => t.code === TRAIT_PARAM_PLUS && t.dataId === id).reduce((a, t) => a + t.value, 0);
        }, 0);
    }

    paramRate(id) {
        return this.traitObjects().reduce((r, obj) => {
            return r * (obj.traits || []).filter(t => t.code === TRAIT_PARAM_RATE && t.dataId === id).reduce((a, t) => a * t.value, 1);
        }, 1);
    }

    addState(id) {
        if (this.isStateAffected(id)) {
            const s = this.states.find(s => s.id === id);
            s.duration = $dataStates[id].duration;
        } else {
            const s = Object.assign({id: id}, $dataStates[id]);
            this.states.push(s);
        }
    }

    removeState(id) { this.states = this.states.filter(s => s.id !== id); }
    isStateAffected(id) { return this.states.some(s => s.id === id); }
    isRestricted() { return this.states.some(s => s.traits.some(t => t.code === TRAIT_RESTRICTION)); }
}

/**
 * Represents a player character (actor).
 */
class Game_Actor {
    /**
     * Creates a new Game_Actor.
     * @param {string} name - The name of the character (must match a key in $dataClasses).
     */
    constructor(name) {
        const d = $dataClasses[name];
        Object.assign(this, d); this.name = name; this.mhp = d.hp; this.mpe = 100; this.pe = d.pe; 
        this.equip = { weapon: null, armor: null }; this.level = 1; this.exp = 0; this.nextExp = 50; this.inventory = [];
        this.states = [];
        if(name === "Aya") this.equip.weapon = new Game_Weapon({name:"M84F", baseAtk:2, icon:"üî´"}, {name:"Std", atk:0});
        if(name === "Kyle") this.equip.armor = new Game_Armor({name:"Vest", baseDef:3, icon:"ü¶∫"});
        this.uid = 'player';
        this.direction = {x:0, y:1};
    }

    isDead() { return this.hp <= 0; }

    takeDamage(v) { this.hp = Math.max(0, this.hp - v); }

    heal(v) { this.hp = Math.min(this.mhp, this.hp + v); }

    regenPE() { this.pe = Math.min(this.mpe, this.pe + 2); }

    gainExp(v) { this.exp += v; if(this.exp >= this.nextExp) { this.level++; this.exp = 0; this.nextExp = Math.floor(this.nextExp*1.5); this.mhp+=5; this.hp=this.mhp; this.atk++; $gameSystem.log(`${this.name} Lv.${this.level}!`); } }

    getAtk() {
        let base = this.atk;
        return Math.floor((base + this.paramPlus(PARAM_ATK)) * this.paramRate(PARAM_ATK));
    }

    getDef() {
        let base = this.def;
        return Math.floor((base + this.paramPlus(PARAM_DEF)) * this.paramRate(PARAM_DEF));
    }

    traitObjects() {
        const objects = [...this.states];
        if (this.equip.weapon) objects.push(this.equip.weapon);
        if (this.equip.armor) objects.push(this.equip.armor);
        return objects;
    }

    paramPlus(id) {
        return this.traitObjects().reduce((r, obj) => {
            return r + (obj.traits || []).filter(t => t.code === TRAIT_PARAM_PLUS && t.dataId === id).reduce((a, t) => a + t.value, 0);
        }, 0);
    }

    paramRate(id) {
        return this.traitObjects().reduce((r, obj) => {
            return r * (obj.traits || []).filter(t => t.code === TRAIT_PARAM_RATE && t.dataId === id).reduce((a, t) => a * t.value, 1);
        }, 1);
    }

    addState(id) {
        if (this.isStateAffected(id)) {
            const s = this.states.find(s => s.id === id);
            s.duration = $dataStates[id].duration;
        } else {
            const s = Object.assign({id: id}, $dataStates[id]);
            this.states.push(s);
        }
    }

    removeState(id) { this.states = this.states.filter(s => s.id !== id); }
    isStateAffected(id) { return this.states.some(s => s.id === id); }
    isRestricted() { return this.states.some(s => s.traits.some(t => t.code === TRAIT_RESTRICTION)); }

    getAttackSkill() {
        const t = this.traitObjects().flatMap(o => o.traits || []).find(t => t.code === TRAIT_ATTACK_SKILL);
        return t ? t.value : null;
    }

    /**
     * Calculates what the attack would be with a specific item equipped.
     * @param {Game_Weapon} i - The item to check.
     * @returns {number} The hypothetical attack value.
     */
    getAtkWith(i) { return this.atk + (i.category === 'weapon' ? i.atk : (this.equip.weapon ? this.equip.weapon.atk : 0)); }

    /**
     * Calculates what the defense would be with a specific item equipped.
     * @param {Game_Armor} i - The item to check.
     * @returns {number} The hypothetical defense value.
     */
    getDefWith(i) { return this.def + (i.category === 'armor' ? i.def : (this.equip.armor ? this.equip.armor.def : 0)); }
}

/**
 * Manages item generation and handling.
 */
class ItemManager {
    /**
     * Generates a random piece of loot based on the current floor.
     * @param {number} floor - The current floor level.
     * @returns {Game_Item|Game_Weapon|Game_Armor} The generated item.
     */
    static generateLoot(floor) {
        const roll = Math.random();
        if (roll < 0.4) {
            const item = $dataLootTable.items[Math.floor(Math.random() * $dataLootTable.items.length)];
            return new Game_Item(item);
        } else if (roll < 0.7) {
            const base = $dataLootTable.weapons[Math.floor(Math.random() * $dataLootTable.weapons.length)];
            const pre = $dataLootTable.prefixes[Math.min(Math.floor(Math.random() * (floor + 2)), $dataLootTable.prefixes.length-1)];
            return new Game_Weapon(base, pre);
        } else {
            const base = $dataLootTable.armors[Math.floor(Math.random() * $dataLootTable.armors.length)];
            return new Game_Armor(base);
        }
    }
}

/**
 * Manages cutscene playback.
 */
class CutsceneManager {
    /**
     * Creates an instance of CutsceneManager.
     */
    constructor() {
        this.queue = [];
        this.active = false;
        this.dialogEl = document.getElementById('cutscene-overlay');
    }

    /**
     * Starts playing a cutscene script.
     * @param {Array<Object>} script - The list of cutscene commands.
     */
    play(script) {
        this.queue = [...script];
        this.active = true;
        $gameSystem.isInputBlocked = true;
        this.next();
    }

    /**
     * Advances to the next command in the cutscene queue.
     */
    next() {
        if(this.queue.length === 0) {
            this.end();
            return;
        }
        const cmd = this.queue.shift();
        this.processCommand(cmd);
    }

    /**
     * Processes a single cutscene command.
     * @param {Object} cmd - The command object.
     */
    processCommand(cmd) {
        switch(cmd.type) {
            case 'dialog':
                this.dialogEl.innerHTML = `
                    <div style="border-bottom:1px solid #444; margin-bottom:5px; padding-bottom:2px; font-weight:bold; color:${cmd.color || '#0ff'}">${cmd.speaker || 'SYSTEM'}</div>
                    <div style="font-size:14px; margin-bottom:10px;">${cmd.text}</div>
                    <div style="font-size:10px; color:#666;">[CLICK TO CONTINUE]</div>
                `;
                this.dialogEl.style.display = 'block';
                const clickHandler = () => {
                    this.dialogEl.style.display = 'none';
                    document.removeEventListener('click', clickHandler);
                    this.next();
                };
                setTimeout(() => document.addEventListener('click', clickHandler), 100);
                break;
            case 'wait':
                setTimeout(() => this.next(), cmd.time);
                break;
            case 'log':
                $gameSystem.log(cmd.text);
                this.next();
                break;
        }
    }

    /**
     * Ends the cutscene and restores control.
     */
    end() {
        this.active = false;
        $gameSystem.isInputBlocked = false;
        $gameSystem.log("Command restored.");
    }
}

/**
 * Manages battle mechanics and skill execution.
 */
class BattleManager {
    /**
     * Calculates damage between a source and a target.
     * @param {Object} source - The attacker.
     * @param {Object} target - The defender.
     * @returns {number} The calculated damage.
     */
    static calcDamage(source, target) {
        let atk = source.getAtk ? source.getAtk() : source.atk;
        let def = target.getDef ? target.getDef() : (target.def || 0);
        const variation = 0.8 + Math.random() * 0.4;
        let dmg = Math.floor((atk * 2 - def) * variation);
        return Math.max(1, dmg);
    }

    /**
     * Executes a skill by an actor.
     * @param {Game_Actor} a - The actor using the skill.
     * @param {string} k - The key/ID of the skill.
     * @returns {Promise<boolean>} Resolves to true if skill was executed successfully, false otherwise.
     */
    static async executeSkill(a, k, target = null) {
        const s = $dataSkills[k];
        if(a.pe < s.cost) { $gameSystem.log("No PE."); return false; }
        a.pe -= s.cost; $gameSystem.log(`${a.name} uses ${s.name}!`);
        Renderer.playAnimation('flash', { color: a.color });
        await Sequencer.sleep(300);
        const baseDmg = s.fixed ? s.power : Math.floor(a.getAtk() * s.power);

        if (target) {
            target.takeDamage(baseDmg);
            Renderer.playAnimation('projectile', { x1: $gameMap.playerX, y1: $gameMap.playerY, x2: target.x, y2: target.y, color: a.color });
            UI.floatText(baseDmg, target.x, target.y, "#f00");
            Renderer.playAnimation('hit', { uid: target.uid });
            if(k==='stun') {
                if(Math.random() < 0.5) {
                    target.addState("stun");
                    UI.floatText("STUN", target.x, target.y, "#ff0");
                }
            }
            if(target.hp <= 0) await $gameMap.killEnemy(target);
            await Sequencer.sleep(500); return true;
        } else if(k === 'rapid') {
            const tgts = $gameMap.enemies.filter(e => Math.abs(e.x - $gameMap.playerX) + Math.abs(e.y - $gameMap.playerY) < s.range);
            if(tgts.length > 0) {
                for(let i=0; i<2; i++) {
                    const t = tgts[Math.floor(Math.random()*tgts.length)];
                    t.takeDamage(baseDmg);
                    Renderer.playAnimation('projectile', { x1: $gameMap.playerX, y1: $gameMap.playerY, x2: t.x, y2: t.y, color: a.color });
                    await Sequencer.sleep(200);
                    UI.floatText(baseDmg, t.x, t.y, "#fff");
                    Renderer.playAnimation('hit', { uid: t.uid });
                    if(t.hp <= 0) await $gameMap.killEnemy(t);
                    await Sequencer.sleep(300);
                }
            }
        } else if(s.type === 'all_enemies') {
            $gameMap.enemies.forEach(e => {
                e.takeDamage(baseDmg); UI.floatText(baseDmg, e.x, e.y, "#f40");
                Renderer.playAnimation('hit', { uid: e.uid });
                if(e.hp <= 0) $gameMap.killEnemy(e);
            });
            Renderer.playAnimation('shake');
        } else if(s.type === 'target') {
            const tgts = $gameMap.enemies.filter(e => Math.abs(e.x - $gameMap.playerX) + Math.abs(e.y - $gameMap.playerY) < s.range);
            if(tgts.length > 0) {
                const t = tgts[0]; t.takeDamage(baseDmg);
                Renderer.playAnimation('projectile', { x1: $gameMap.playerX, y1: $gameMap.playerY, x2: t.x, y2: t.y, color: a.color });
                UI.floatText(baseDmg, t.x, t.y, "#f00");
                if(k==='drain') { a.heal(baseDmg); UI.floatText("+"+baseDmg, $gameMap.playerX, $gameMap.playerY, "#0f0"); }
                if(k==='stun') {
                    if(Math.random() < 0.5) {
                        t.addState("stun");
                        UI.floatText("STUN", t.x, t.y, "#ff0");
                    }
                }
                if(t.hp <= 0) await $gameMap.killEnemy(t);
            }
        } else if (s.type === 'self') {
            if (k === 'heal') {
                a.heal(s.power);
                UI.floatText("+" + s.power, $gameMap.playerX, $gameMap.playerY, "#0f0");
            } else if (k === 'barrier') {
                a.addState("barrier");
                UI.floatText("BARRIER", $gameMap.playerX, $gameMap.playerY, "#0ff");
            } else if (k === 'scan') {
                $gameMap.revealZone($gameMap.width/2, $gameMap.height/2, 100);
                UI.refreshMinimap();
                UI.floatText("SCAN", $gameMap.playerX, $gameMap.playerY, "#0ff");
            }
        }
        await Sequencer.sleep(500); return true;
    }
}

/**
 * Manages the party of actors.
 */
class Game_Party {
    /**
     * Creates an instance of Game_Party.
     */
    constructor() { this.members = [new Game_Actor("Aya"), new Game_Actor("Kyle"), new Game_Actor("Eve")]; this.index = 0; this.inventory = []; this.maxInventory = 20; }

    /**
     * Gets the currently active party member.
     * @returns {Game_Actor} The active actor.
     */
    active() { return this.members[this.index]; }

    /**
     * Gets the next party member in the rotation.
     * @returns {Game_Actor} The next actor.
     */
    nextActive() { return this.members[(this.index + 1) % 3]; }

    /**
     * Rotates to the next living party member.
     */
    rotate() {
        let s = 3; do { this.index = (this.index + 1) % 3; s--; } while(this.active().isDead() && s > 0);
        if(this.active().isDead()) SceneManager.gameOver();
    }

    /**
     * Distributes experience points to the party.
     * @param {number} a - The base amount of experience.
     */
    distributeExp(a) { const k = this.active(); this.members.forEach(m => !m.isDead() && m.gainExp(m===k ? a : Math.floor(a*0.5))); }

    /**
     * Adds an item to the party's inventory.
     * @param {Game_Item|Game_Weapon|Game_Armor} i - The item to gain.
     */
    gainItem(i) { if(this.inventory.length < this.maxInventory) { this.inventory.push(i); $gameSystem.log(`Got ${i.icon}${i.name}`); } else { $gameSystem.log("Inv Full!"); } }
}

/**
 * Manages the game map, level generation, and entity placement.
 */
class Game_Map {
    /**
     * Creates an instance of Game_Map.
     */
    constructor() { this.width = 20; this.height = 20; this.tiles = []; this.visited = []; this.enemies = []; this.loot = []; this.playerX = 1; this.playerY = 1; this.enemyIdCounter = 0; }

    /**
     * Sets up a new floor.
     * @param {number} floor - The floor level to generate.
     */
    setup(floor) {
        $gameSystem.floor = floor; $gameSystem.log(`>> SECTOR ${floor}`);
        const c = $dataFloors[floor] || $dataFloors.default;
        this.width = c.width; this.height = c.height;
        this.tiles = Array(this.width).fill(0).map(()=>Array(this.height).fill(1));
        this.visited = Array(this.width).fill(0).map(()=>Array(this.height).fill(false));
        const rooms = [];
        for(let i=0; i<c.rooms; i++) {
            const w = 4+Math.floor(Math.random()*5), h = 4+Math.floor(Math.random()*5);
            const x = Math.floor(Math.random()*(this.width-w-2))+1, y = Math.floor(Math.random()*(this.height-h-2))+1;
            let ov = false;
            for(let r of rooms) if(x<r.x+r.w+1 && x+w+1>r.x && y<r.y+r.h+1 && y+h+1>r.y) { ov = true; break; }
            if(!ov) {
                rooms.push({x,y,w,h,cx:Math.floor(x+w/2), cy:Math.floor(y+h/2)});
                for(let rx=x; rx<x+w; rx++) for(let ry=y; ry<y+h; ry++) this.tiles[rx][ry] = 0;
                if(rooms.length > 1) this.carveTunnel(rooms[rooms.length-2].cx, rooms[rooms.length-2].cy, rooms[rooms.length-1].cx, rooms[rooms.length-1].cy);
            }
        }
        if(rooms.length > 0) {
            this.playerX = rooms[0].cx; this.playerY = rooms[0].cy;
            this.stairsX = rooms[rooms.length-1].cx; this.stairsY = rooms[rooms.length-1].cy;
            this.tiles[this.stairsX][this.stairsY] = 3;
        }
        this.revealZone(this.playerX, this.playerY, 6);
        this.enemies = []; this.loot = [];
        for(let i=0; i<c.enemies+floor; i++) {
            const pt = this.getRandomPoint();
            if(pt) this.enemies.push(new Game_Enemy($dataEnemies[Math.floor(Math.random()*$dataEnemies.length)], pt.x, pt.y, this.enemyIdCounter++, 10+floor*2));
        }
        for(let i=0; i<c.loot; i++) {
            const pt = this.getRandomPoint();
            if(pt) this.loot.push({x: pt.x, y: pt.y, item: ItemManager.generateLoot(floor)});
        }
        Renderer.rebuildLevel();
        if(c.cutscene) Cutscene.play($dataCutscenes[c.cutscene]);
        UI.refreshMinimap();
    }

    /**
     * Gets a random empty point on the map.
     * @returns {Object|null} An object with x and y coordinates, or null if failed.
     */
    getRandomPoint() {
        for(let i=0; i<200; i++) {
            const x = Math.floor(Math.random()*this.width), y = Math.floor(Math.random()*this.height);
            if(this.tiles[x][y] === 0 && (x!==this.playerX || y!==this.playerY) && (x!==this.stairsX || y!==this.stairsY)) return {x,y};
        }
        return null;
    }

    /**
     * Carves a tunnel between two points.
     * @param {number} x1 - Start x.
     * @param {number} y1 - Start y.
     * @param {number} x2 - End x.
     * @param {number} y2 - End y.
     */
    carveTunnel(x1,y1,x2,y2) {
        if(Math.random()<0.5) { this.hTunnel(x1,x2,y1); this.vTunnel(y1,y2,x2); } else { this.vTunnel(y1,y2,x1); this.hTunnel(x1,x2,y2); }
    }

    /**
     * Carves a horizontal tunnel.
     * @param {number} x1 - Start x.
     * @param {number} x2 - End x.
     * @param {number} y - Y coordinate.
     */
    hTunnel(x1,x2,y) { for(let x=Math.min(x1,x2); x<=Math.max(x1,x2); x++) if(this.isValid(x,y)) this.tiles[x][y]=0; }

    /**
     * Carves a vertical tunnel.
     * @param {number} y1 - Start y.
     * @param {number} y2 - End y.
     * @param {number} x - X coordinate.
     */
    vTunnel(y1,y2,x) { for(let y=Math.min(y1,y2); y<=Math.max(y1,y2); y++) if(this.isValid(x,y)) this.tiles[x][y]=0; }

    /**
     * Checks if a coordinate is valid.
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @returns {boolean} True if valid.
     */
    isValid(x,y) { return x>=0 && x<this.width && y>=0 && y<this.height && this.tiles[x] !== undefined; }

    /**
     * Reveals a zone on the minimap.
     * @param {number} cx - Center X.
     * @param {number} cy - Center Y.
     * @param {number} radius - Radius of the zone.
     */
    revealZone(cx, cy, radius) {
        for(let x=cx-radius; x<=cx+radius; x++) {
            for(let y=cy-radius; y<=cy+radius; y++) {
                if(this.isValid(x, y) && (Math.abs(x-cx) + Math.abs(y-cy) <= radius)) {
                    this.visited[x][y] = true;
                }
            }
        }
    }

    /**
     * Processes a game turn based on player movement.
     * @param {number} dx - Change in x.
     * @param {number} dy - Change in y.
     * @param {Function} [action] - Optional action to execute.
     */
    async processTurn(dx, dy) {
        if($gameSystem.isInputBlocked) return;
        
        // Check Renderer state for Seamless Movement Throttling
        if(Renderer && Renderer.isAnimating) return;

        // Player State Logic
        const actor = $gameParty.active();

        // Update Direction if moving
        if (dx !== 0 || dy !== 0) {
            $gameParty.members.forEach(m => m.direction = {x: dx, y: dy});
        }

        if(actor.isRestricted()) {
             $gameSystem.log(`${actor.name} is stunned!`);
             // Skip movement but process turn end for states
             await this.processTurnEnd(actor);
             await this.updateEnemies();
             return;
        }

        const nx = this.playerX + dx; const ny = this.playerY + dy;
        if(this.tiles[nx][ny] === 1) return;
        
        const enemy = this.enemies.find(e => e.x === nx && e.y === ny);

        if(enemy) {
             this.playerAttack();
        } else {
            // TRIGGER VISUAL SWAP
            Renderer.playAnimation('move_switch', { 
                fromX: this.playerX, fromY: this.playerY, 
                toX: nx, toY: ny, 
                nextColor: $gameParty.nextActive().color 
            });
            this.playerX = nx; this.playerY = ny;
            this.revealZone(this.playerX, this.playerY, 6);
            
            // NO SLEEP - allow continuous input buffer via Renderer flag
            
            const itemIdx = this.loot.findIndex(i => i.x === nx && i.y === ny);
            if(itemIdx > -1) {
                $gameParty.gainItem(this.loot[itemIdx].item);
                Renderer.playAnimation('itemGet', { x: nx, y: ny });
                this.loot.splice(itemIdx, 1);
                Renderer.syncLoot();
            }
            
            if(this.tiles[nx][ny] === 3) {
                $gameSystem.log("Ascending...");
                Renderer.playAnimation('ascend'); 
                $gameSystem.isInputBlocked = true; 
                // Wait slightly more for dramatic effect before logic switch
                await Sequencer.sleep(4000); 
                $gameSystem.isInputBlocked = false;
                this.setup($gameSystem.floor + 1);
                return;
            }

            // End of action for the actor who moved/acted (which is technically the one leaving)
            // But wait, $gameParty.rotate() changes active member.
            // Logic: Current actor moves. Then we rotate.
            // Should states update on the actor who just acted?
            // Yes.
            await this.processTurnEnd($gameParty.active());

            $gameParty.rotate();
            UI.refresh();
            this.updateEnemies(); 
        }
    }

    async processTurnEnd(actor) {
        // Update states
        for(let i = actor.states.length - 1; i >= 0; i--) {
            const s = actor.states[i];
            s.duration--;
            if(s.id === 'poison') {
                const dmg = Math.floor(actor.mhp * 0.05);
                actor.takeDamage(dmg);
                $gameSystem.log(`${actor.name} takes poison dmg!`);
                UI.floatText(dmg, this.playerX, this.playerY, "#808");
                if(actor.isDead()) {
                     // Handle death if active actor dies?
                     // Currently handled in rotate() or game loop checks?
                     // rotate() checks if dead and skips.
                     // But if active actor dies here, next rotate will handle it.
                }
            }
            if(s.duration <= 0) {
                actor.removeState(s.id);
                $gameSystem.log(`${actor.name}'s ${s.name} faded.`);
            }
        }
    }

    /**
     * Updates enemy positions and actions.
     */
    async updateEnemies() {
        for(const e of this.enemies) {
            // Enemy State Logic
            let restricted = false;
            for(let i = e.states.length - 1; i >= 0; i--) {
                const s = e.states[i];
                s.duration--;
                if(s.traits.some(t => t.code === TRAIT_RESTRICTION)) restricted = true;
                if(s.duration <= 0) e.removeState(s.id);
            }
            if(restricted) continue;

            const dist = Math.abs(e.x - this.playerX) + Math.abs(e.y - this.playerY);
            if(dist < 7) e.alerted = true;
            if(e.alerted) {
                let dx = 0, dy = 0;
                if(e.ai === "hunter" || e.ai === "ambush") {
                    dx = Math.sign(this.playerX - e.x); dy = Math.sign(this.playerY - e.y);
                    if(Math.random() < 0.5 && dx !== 0) dy = 0; else if(dy !== 0) dx = 0;
                }
                const nx = e.x + dx; const ny = e.y + dy;
                if(nx === this.playerX && ny === this.playerY) {
                    const target = $gameParty.active();
                    const dmg = BattleManager.calcDamage(e, target);
                    target.takeDamage(dmg);
                    Renderer.playAnimation('enemyLunge', { uid: e.uid, tx: nx, ty: ny });
                    UI.floatText(dmg, this.playerX, this.playerY, "#f00");
                    Renderer.playAnimation('hit', { uid: 'player' });
                } else if(this.tiles[nx][ny] === 0 && !this.enemies.find(en => en.x === nx && en.y === ny)) {
                    e.x = nx; e.y = ny;
                    Renderer.syncEnemies();
                }
            }
        }
    }

    /**
     * Handles the death of an enemy.
     * @param {Game_Enemy} enemy - The enemy to kill.
     */
    async killEnemy(enemy) {
        Renderer.playAnimation('die', { uid: enemy.uid });
        await Sequencer.sleep(300);
        this.enemies = this.enemies.filter(e => e !== enemy);
        $gameParty.distributeExp(enemy.exp);
        $gameSystem.log(`${enemy.name} dissolved.`);
        Renderer.syncEnemies();
    }

    async playerAttack() {
        if ($gameSystem.isBusy || $gameSystem.isInputBlocked || Renderer.isAnimating) return;
        $gameSystem.isBusy = true;
        const actor = $gameParty.active();

        // Determine skill
        const attackSkillId = actor.getAttackSkill();
        const skill = attackSkillId ? $dataSkills[attackSkillId] : null;

        let target = null;
        let skillIdToExec = attackSkillId;

        if (skill && skill.type === 'line') {
            const dx = actor.direction.x; const dy = actor.direction.y;
            for (let i=1; i<=skill.range; i++) {
                 const tx = this.playerX + dx * i; const ty = this.playerY + dy * i;
                 if (!this.isValid(tx, ty) || this.tiles[tx][ty] === 1) break;
                 const e = this.enemies.find(en => en.x === tx && en.y === ty);
                 if (e) { target = e; break; }
            }
            // Execute even if no target (miss)
        } else {
            // Default melee range 1
             const dx = actor.direction.x; const dy = actor.direction.y;
             const tx = this.playerX + dx; const ty = this.playerY + dy;
             target = this.enemies.find(en => en.x === tx && en.y === ty);
             if (!skillIdToExec && target) {
                 // Normal attack logic logic is inside processTurn, but here we want to force attack
                 // Since we don't have a skill ID for normal attack, we can simulate it or wrap it.
                 // Ideally standard attack is a skill too, but it isn't implemented as such fully.
                 // If no custom skill, we do standard melee damage.
             }
        }

        if (skillIdToExec) {
            if (!target) {
                // MISS VISUAL
                $gameSystem.log(`${actor.name} attacks empty air.`);
                const dx = actor.direction.x; const dy = actor.direction.y;
                Renderer.playAnimation('projectile', { x1: this.playerX, y1: this.playerY, x2: this.playerX + dx*5, y2: this.playerY + dy*5, color: actor.color });
                await Sequencer.sleep(300);
            } else {
                await BattleManager.executeSkill(actor, skillIdToExec, target);
            }
        } else {
            // Basic Attack (No skill override)
            if (target) {
                const dmg = BattleManager.calcDamage(actor, target);
                target.takeDamage(dmg);
                Renderer.playAnimation('lunge', { tx: target.x, ty: target.y });
                await Sequencer.sleep(150);
                UI.floatText(dmg, target.x, target.y, "#fff");
                Renderer.playAnimation('hit', { uid: target.uid });
                await Sequencer.sleep(200);
                $gameSystem.log(`Hit ${target.name} for ${dmg}.`);
                if(target.hp <= 0) await this.killEnemy(target);
            } else {
                $gameSystem.log(`${actor.name} swings at nothing.`);
                Renderer.playAnimation('lunge', { tx: this.playerX + actor.direction.x, ty: this.playerY + actor.direction.y });
                await Sequencer.sleep(300);
            }
        }

        $gameParty.rotate();
        UI.refresh();
        await this.updateEnemies();
        $gameSystem.isBusy = false;
        await this.processTurnEnd(actor);
    }
}

// ============================================================================
// [5] RENDERER
// ============================================================================
/**
 * System for handling particle effects in the 3D scene.
 */
class ParticleSystem {
    /**
     * Creates an instance of ParticleSystem.
     * @param {THREE.Scene} scene - The Three.js scene to add particles to.
     */
    constructor(scene) {
        this.scene = scene; this.particles = [];
        const geo = new THREE.PlaneGeometry(0.1, 0.1);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true });
        for(let i=0; i<50; i++) {
            const p = new THREE.Mesh(geo, mat.clone()); p.visible = false; scene.add(p);
            this.particles.push({ mesh: p, life: 0, velocity: new THREE.Vector3() });
        }
    }

    /**
     * Spawns a burst of particles.
     * @param {number} x - X coordinate.
     * @param {number} y - Z coordinate.
     * @param {number} color - Hex color.
     * @param {number} [count=10] - Number of particles.
     */
    spawnBurst(x, y, color, count=10) {
        let spawned = 0;
        for(let p of this.particles) {
            if(p.life <= 0 && spawned < count) {
                p.mesh.visible = true; p.mesh.position.set(x, 0.5, y);
                p.mesh.material.color.setHex(color); p.mesh.material.opacity = 1;
                const angle = Math.random() * Math.PI * 2; const speed = 0.05 + Math.random() * 0.05;
                p.velocity.set(Math.cos(angle) * speed, (Math.random() * 0.1), Math.sin(angle) * speed);
                p.life = 1.0; spawned++;
            }
        }
    }

    /**
     * Spawns sparkle effects.
     * @param {number} x - X coordinate.
     * @param {number} y - Z coordinate.
     */
    spawnSparkle(x, y) {
        let count = 5; let spawned = 0;
        for(let p of this.particles) {
             if(p.life <= 0 && spawned < count) {
                p.mesh.visible = true;
                p.mesh.position.set(x + (Math.random()-0.5)*0.5, 0.2, y + (Math.random()-0.5)*0.5);
                p.mesh.material.color.setHex(0xffff00); p.mesh.material.opacity = 1;
                p.life = 1.5; p.velocity.set(0, 0.03 + Math.random()*0.02, 0);
                spawned++;
             }
        }
    }

    /**
     * Updates all active particles.
     */
    update() {
        for(let p of this.particles) {
            if(p.life > 0) {
                p.life -= 0.02; p.mesh.position.add(p.velocity);
                p.mesh.material.opacity = Math.min(1, p.life); p.mesh.rotation.z += 0.1;
                if(p.life <= 0) p.mesh.visible = false;
            }
        }
    }
}

/**
 * Main 3D renderer using Three.js.
 */
class Renderer3D {
    /**
     * Creates an instance of Renderer3D.
     */
    constructor() {
        this.scene = null; this.camera = null; this.renderer = null;
        this.meshes = { map: [], enemies: [], loot: [] };
        this.playerTarget = new THREE.Vector3();
        this.lungeTarget = null;
        this.enemyTargets = new Map(); 
        this.enemyLunges = new Map(); 
        this.shakeTargets = new Map(); 
        this.rangeGroup = new THREE.Group();
        this.cameraLookCurrent = new THREE.Vector3();
        this.particles = null;
        this.moveLerpStart = new THREE.Vector3();
        this.moveLerpEnd = new THREE.Vector3();
        this.moveLerpProgress = 1; 
        this.nextColor = null;
        this.spinProgress = 0;
        this.isSpinning = false;
        this.isAscending = false;
        this.ascendProgress = 0;
        this.zoomProgress = 0;
        this.isAnimating = false;
        this.instancedFloor = null;
        this.instancedWalls = null;
        this.currentRangeSkill = null;
    }

    /**
     * Initializes the Three.js scene.
     * @param {HTMLElement} container - The DOM element to append the canvas to.
     */
    init(container) {
        if(!container) return;
        this.container = container;
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(CONFIG.colors.bg);
        this.scene.fog = new THREE.Fog(CONFIG.colors.fog, 4, 14);

        const w = container.clientWidth;
        const h = container.clientHeight;
        // Aspect ratio based on actual container size
        this.camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 16);

        this.renderer = new THREE.WebGLRenderer({ antialias: false });
        // Viewport is half the size of the window, scaled up
        this.renderer.setSize(Math.floor(w/2), Math.floor(h/2), false);
        this.renderer.domElement.id = 'game-canvas';
        container.innerHTML = ''; 
        const wrapper = document.createElement('div');
        wrapper.id = 'game-view-wrapper'; wrapper.style.width = '100%'; wrapper.style.height = '100%';
        wrapper.appendChild(this.renderer.domElement); container.appendChild(wrapper);

        this.scene.add(new THREE.AmbientLight(0x222222));
        const dirLight = new THREE.DirectionalLight(0x555555, 0.6); dirLight.position.set(10, 20, 10); this.scene.add(dirLight);
        this.playerLight = new THREE.PointLight(0x004444, 1.5, 15); this.scene.add(this.playerLight);

        const geo = new THREE.OctahedronGeometry(0.35);
        this.matPlayer = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x001133 });
        this.playerMesh = new THREE.Mesh(geo, this.matPlayer);
        this.playerMesh.userData.uid = 'player'; 
        this.scene.add(this.playerMesh);

        this.mapGroup = new THREE.Group(); this.enemyGroup = new THREE.Group(); this.lootGroup = new THREE.Group(); this.rangeGroup = new THREE.Group();
        this.scene.add(this.mapGroup); this.scene.add(this.enemyGroup); this.scene.add(this.lootGroup); this.scene.add(this.rangeGroup);
        this.particles = new ParticleSystem(this.scene);
        this.animate();
    }

    /**
     * Rebuilds the level geometry based on map data.
     */
    rebuildLevel() {
        this.mapGroup.clear();
        const count = $gameMap.width * $gameMap.height;
        const geoFloor = new THREE.PlaneGeometry(0.95, 0.95);
        const matFloor = new THREE.MeshLambertMaterial({ color: CONFIG.colors.floor });
        this.instancedFloor = new THREE.InstancedMesh(geoFloor, matFloor, count);
        const geoBlock = new THREE.BoxGeometry(0.95, 1, 0.95);
        const matWall = new THREE.MeshLambertMaterial({ color: CONFIG.colors.wall });
        this.instancedWalls = new THREE.InstancedMesh(geoBlock, matWall, count);
        const dummy = new THREE.Object3D();
        let fIdx = 0, wIdx = 0;
        
        for(let x=0; x<$gameMap.width; x++) {
            for(let y=0; y<$gameMap.height; y++) {
                if($gameMap.tiles[x][y] === 0 || $gameMap.tiles[x][y] === 3) {
                    dummy.position.set(x, 0, y); dummy.rotation.set(-Math.PI/2, 0, 0); dummy.scale.set(1,1,1); dummy.updateMatrix();
                    this.instancedFloor.setMatrixAt(fIdx++, dummy.matrix);
                    if($gameMap.tiles[x][y] === 3) {
                        const numSteps = 5; const maxH = 0.4; const sliceW = 0.8 / numSteps; 
                        for(let s=0; s<numSteps; s++) {
                            const h = maxH * (numSteps - s) / numSteps;
                            const yPos = h / 2; const zPos = y - 0.4 + (s * sliceW) + (sliceW / 2); 
                            const step = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, sliceW * 0.9), new THREE.MeshPhongMaterial({ color: 0x00ffaa, flatShading: true }));
                            step.position.set(x, yPos, zPos); this.mapGroup.add(step);
                        }
                    }
                } else if ($gameMap.tiles[x][y] === 1) {
                     if(this.hasFloorNeighbor(x,y)) {
                        dummy.position.set(x, 0.5, y); dummy.rotation.set(0,0,0); dummy.scale.set(1,1,1); dummy.updateMatrix();
                        this.instancedWalls.setMatrixAt(wIdx++, dummy.matrix);
                     }
                }
            }
        }
        this.instancedFloor.count = fIdx; this.instancedWalls.count = wIdx;
        this.instancedFloor.instanceMatrix.needsUpdate = true; this.instancedWalls.instanceMatrix.needsUpdate = true;
        this.mapGroup.add(this.instancedFloor); this.mapGroup.add(this.instancedWalls);
        
        this.playerMesh.position.set($gameMap.playerX, 0.5, $gameMap.playerY);
        this.playerTarget.set($gameMap.playerX, 0.5, $gameMap.playerY);
        this.cameraLookCurrent.set($gameMap.playerX, 0, $gameMap.playerY); 
        this.isAscending = false; this.ascendProgress = 0; this.zoomProgress = 0; this.playerMesh.visible = true;
        this.syncEnemies(); this.syncLoot();
    }

    /**
     * Checks if a wall has a floor neighbor, for optimization.
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @returns {boolean} True if a floor neighbor exists.
     */
    hasFloorNeighbor(x,y) {
        const t = $gameMap.tiles;
        const check = (nx, ny) => nx>=0 && nx<$gameMap.width && ny>=0 && ny<$gameMap.height && t[nx][ny] !== 1;
        return check(x+1,y) || check(x-1,y) || check(x,y+1) || check(x,y-1);
    }

    /**
     * Synchronizes 3D enemy representations with game data.
     */
    syncEnemies() {
        const cIds = new Set($gameMap.enemies.map(e => e.uid));
        for(let i = this.enemyGroup.children.length - 1; i >= 0; i--) {
            const c = this.enemyGroup.children[i];
            if(!cIds.has(c.userData.uid)) { this.enemyGroup.remove(c); this.enemyTargets.delete(c.userData.uid); }
        }
        $gameMap.enemies.forEach(e => {
            let mesh = this.enemyGroup.children.find(c => c.userData.uid === e.uid);
            if(!mesh) {
                const geo = new THREE.ConeGeometry(0.3 * e.scale, 0.8 * e.scale, 4);
                const mat = new THREE.MeshPhongMaterial({ color: e.color, flatShading: true });
                mesh = new THREE.Mesh(geo, mat);
                mesh.userData = { uid: e.uid, scaleBase: e.scale };
                mesh.position.set(e.x, 0.4, e.y);
                this.enemyGroup.add(mesh);
                this.enemyTargets.set(e.uid, new THREE.Vector3(e.x, 0.4, e.y));
            } else {
                const target = this.enemyTargets.get(e.uid); if(target) target.set(e.x, 0.4, e.y);
            }
        });
    }

    /**
     * Synchronizes 3D loot representations with game data.
     */
    syncLoot() {
        this.lootGroup.clear();
        $gameMap.loot.forEach(l => {
            const m = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshPhongMaterial({ color: 0xffd700, wireframe: true }));
            m.position.set(l.x, 0.25, l.y);
            this.lootGroup.add(m);
        });
    }

    /**
     * Plays a visual animation.
     * @param {string} type - The type of animation (e.g., 'move_switch', 'lunge').
     * @param {Object} data - Data required for the animation.
     */
    playAnimation(type, data) {
        if (type === 'move_switch') {
            this.moveLerpStart.copy(this.playerMesh.position);
            this.moveLerpEnd.set(data.toX, 0.5, data.toY);
            this.nextColor = data.nextColor;
            this.moveLerpProgress = 0;
            this.playerTarget.set(data.toX, 0.5, data.toY);
            this.isAnimating = true; // Lock input during move
        } else if (type === 'ascend') {
            this.isAscending = true;
            this.ascendProgress = 0;
            this.zoomProgress = 0;
        } else if (type === 'lunge') {
            this.lungeTarget = new THREE.Vector3(data.tx, 0.5, data.ty);
            setTimeout(() => { this.lungeTarget = null; }, 150);
        } else if (type === 'enemyLunge') {
            this.enemyLunges.set(data.uid, new THREE.Vector3(data.tx, 0.4, data.ty));
            setTimeout(() => { this.enemyLunges.delete(data.uid); }, 150);
        } else if (type === 'shake') {
            const el = document.getElementById('game-view-wrapper');
            el.style.transform = `translate(${Math.random()*6-3}px, ${Math.random()*6-3}px)`;
            setTimeout(() => el.style.transform = 'none', 50);
        } else if (type === 'hit') {
            if (data.uid !== undefined) {
                this.shakeTargets.set(data.uid, 5); 
                const pos = data.uid==='player' ? this.playerMesh.position : this.enemyGroup.children.find(c=>c.userData.uid===data.uid)?.position;
                if(pos) this.particles.spawnBurst(pos.x, pos.z, 0xff0000, 5);
            }
        } else if (type === 'itemGet') {
            this.particles.spawnSparkle(data.x, data.y);
        } else if (type === 'flash') {
            this.flash(data.color);
        } else if (type === 'die') {
            const target = this.enemyGroup.children.find(c => c.userData.uid === data.uid);
            if(target) this.particles.spawnBurst(target.position.x, target.position.z, 0xaaaaaa, 10);
        }
    }

    /**
     * Projects a 3D coordinate to screen space.
     * @param {number} x - 3D x.
     * @param {number} y - 3D y.
     * @param {number} z - 3D z.
     * @returns {Object} Screen coordinates {x, y}.
     */
    projectToScreen(x, y, z) {
        if (!this.container) return { x: 0, y: 0 };

        // Calculate offset relative to app-container to work in logical 960x540 space
        let el = this.container;
        let offX = 0;
        let offY = 0;

        const app = document.getElementById('app-container');
        while (el && el !== app) {
            offX += el.offsetLeft;
            offY += el.offsetTop;
            el = el.offsetParent;
        }

        // Use client width/height which are logical pixels (ignores transform scale)
        const w = this.container.clientWidth;
        const h = this.container.clientHeight;

        const vec = new THREE.Vector3(x, y, z);
        vec.project(this.camera);

        const localX = (vec.x * 0.5 + 0.5) * w;
        const localY = (-vec.y * 0.5 + 0.5) * h;

        return {
            x: localX + offX,
            y: localY + offY
        };
    }

    /**
     * Main animation loop.
     */
    animate() {
        requestAnimationFrame(() => this.animate());
        
        if (this.isAscending) {
            // 1. ZOOM PHASE
            if(this.zoomProgress < 1) {
                this.zoomProgress += 0.02; // Slower Zoom
                // Dolly In
                const lx = this.playerTarget.x; const lz = this.playerTarget.z;
                this.cameraLookCurrent.x += (lx - this.cameraLookCurrent.x) * 0.1;
                this.cameraLookCurrent.z += (lz - this.cameraLookCurrent.z) * 0.1;
                
                const targetX = this.playerTarget.x; 
                const targetZ = this.playerTarget.z + 3; // Closer
                const targetY = 3; // Lower
                this.camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.05);
                this.camera.lookAt(this.playerTarget.x, 0, this.playerTarget.z); // Look at stair base
            }

            // 2. FLY PHASE (Triggered after zoom is mostly done)
            if(this.zoomProgress > 0.8) {
                this.ascendProgress += 0.015;
                const y = 0.5 + (this.ascendProgress * this.ascendProgress * this.ascendProgress * 50); 
                this.playerMesh.position.y = y;
                // Light STAYS DOWN (don't update playerLight pos)
            }
        } else {
             // --- CUSTOM MOVE & SWAP LOGIC ---
            if (this.moveLerpProgress < 1) {
                this.moveLerpProgress += 0.06; // SLOWER VISUALS (approx 16 frames)
                
                // EARLY UNLOCK FOR SEAMLESS INPUT
                if(this.moveLerpProgress > 0.85) {
                     this.isAnimating = false; 
                }
                
                if(this.moveLerpProgress >= 1) this.moveLerpProgress = 1;
                
                this.playerMesh.position.lerpVectors(this.moveLerpStart, this.moveLerpEnd, this.moveLerpProgress);
                
                if (this.moveLerpProgress >= 0.5 && this.matPlayer.color.getHex() !== this.nextColor) {
                    this.matPlayer.color.setHex(this.nextColor);
                }
                this.playerMesh.rotation.y = this.moveLerpProgress * Math.PI * 2;
            } else {
                this.playerMesh.rotation.y = 0; 
                if (this.lungeTarget) this.playerMesh.position.lerp(this.lungeTarget, 0.3);
                else this.playerMesh.position.lerp(this.playerTarget, 0.3); 
            }

            if(!this.isAscending) {
                this.playerMesh.position.y = 0.5 + Math.sin(Date.now()*0.005)*0.05;
                this.playerLight.position.copy(this.playerMesh.position).add(new THREE.Vector3(0, 1, 0));
                
                if(this.camera) {
                    const lx = this.playerTarget.x; const lz = this.playerTarget.z;
                    this.cameraLookCurrent.x += (lx - this.cameraLookCurrent.x) * 0.1;
                    this.cameraLookCurrent.z += (lz - this.cameraLookCurrent.z) * 0.1;
                    const tx = this.playerTarget.x; const tz = this.playerTarget.z + 6; const ty = 6; 
                    this.camera.position.x += (tx - this.camera.position.x) * 0.1;
                    this.camera.position.z += (tz - this.camera.position.z) * 0.1;
                    this.camera.position.y += (ty - this.camera.position.y) * 0.1;
                    this.camera.lookAt(this.cameraLookCurrent.x, 0, this.cameraLookCurrent.z - 2);
                }
            }
        }

        if (this.shakeTargets.has('player')) {
            const f = this.shakeTargets.get('player');
            if (f > 0) {
                this.playerMesh.position.x += (Math.random()-0.5)*0.2; this.playerMesh.position.z += (Math.random()-0.5)*0.2;
                this.shakeTargets.set('player', f - 1);
            } else this.shakeTargets.delete('player');
        }
        
        this.enemyGroup.children.forEach(mesh => {
            const uid = mesh.userData.uid;
            if (this.enemyLunges.has(uid)) mesh.position.lerp(this.enemyLunges.get(uid), 0.3);
            else {
                const t = this.enemyTargets.get(uid); if(t) mesh.position.lerp(t, 0.15);
            }
            if (this.shakeTargets.has(uid)) {
                const f = this.shakeTargets.get(uid);
                if (f > 0) {
                    mesh.position.x += (Math.random()-0.5)*0.15; mesh.position.z += (Math.random()-0.5)*0.15;
                    this.shakeTargets.set(uid, f - 1);
                } else this.shakeTargets.delete(uid);
            }
            const s = mesh.userData.scaleBase || 1.0;
            const pulse = s * (1 + Math.sin(Date.now() * 0.008 + uid) * 0.1);
            mesh.scale.set(1, pulse, 1); mesh.rotation.y += 0.02;
        });

        this.lootGroup.children.forEach(l => { l.rotation.y += 0.02; l.rotation.x += 0.01; });
        this.particles.update();

        // Idle Range Display
        if (!$gameSystem.isBusy && !$gameSystem.isInputBlocked && !this.isAnimating) {
            const actor = $gameParty.active();
            const skillId = actor.getAttackSkill();

            // Show range for skill OR default range 1
            if (skillId) this.showRange($dataSkills[skillId]);
            else this.showRange({range: 1, type: 'target'}); // Default melee range
        } else {
            this.clearRange();
        }

        this.renderer.render(this.scene, this.camera);
    }

    /**
     * Displays a range indicator for a skill.
     * @param {Object} skill - The skill object.
     */
    showRange(skill) {
        // Optimization check - check both skill ref and direction
        const actor = $gameParty.active();
        // Since we use direction now, we must clear if direction changed
        if (this.currentRangeSkill === skill && this.lastRangeDir && this.lastRangeDir.x === actor.direction.x && this.lastRangeDir.y === actor.direction.y) return;

        this.currentRangeSkill = skill;
        this.lastRangeDir = { ...actor.direction };

        if (!this.rangeGroup) return; 
        this.rangeGroup.clear();
        if (!skill) return; 
        const geo = new THREE.PlaneGeometry(0.9, 0.9);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const px = $gameMap.playerX; const py = $gameMap.playerY; const coords = [];

        if (skill.type === 'all_enemies') { $gameMap.enemies.forEach(e => coords.push({x: e.x, y: e.y})); }
        else if (skill.range > 0) {
            if (skill.type === 'line') {
                const dx = actor.direction.x; const dy = actor.direction.y;
                for(let i=1; i<=skill.range; i++) {
                    const tx = px + dx*i; const ty = py + dy*i;
                    if (!$gameMap.isValid(tx, ty) || $gameMap.tiles[tx][ty] === 1) break;
                    coords.push({x: tx, y: ty});
                }
            } else if (skill.range === 1) {
                // Directional melee indicator
                const dx = actor.direction.x; const dy = actor.direction.y;
                const tx = px + dx; const ty = py + dy;
                if ($gameMap.isValid(tx, ty) && $gameMap.tiles[tx][ty] !== 1) coords.push({x: tx, y: ty});
            } else {
                for(let x = px - skill.range; x <= px + skill.range; x++) {
                    for(let y = py - skill.range; y <= py + skill.range; y++) {
                        if (Math.abs(x - px) + Math.abs(y - py) <= skill.range && $gameMap.isValid(x, y) && $gameMap.tiles[x][y] === 0) coords.push({x, y});
                    }
                }
            }
        }
        coords.forEach(c => {
            const m = new THREE.Mesh(geo, mat);
            m.rotation.x = -Math.PI / 2;
            m.position.set(c.x, 0.02, c.y);
            this.rangeGroup.add(m);
        });
    }

    /**
     * Clears the range indicator.
     */
    clearRange() {
        if (this.currentRangeSkill === null) return;
        this.currentRangeSkill = null;
        if (this.rangeGroup) this.rangeGroup.clear();
    }

    /**
     * Triggers a screen shake effect.
     */
    shake() {
        const el = document.getElementById('game-view-wrapper');
        el.style.transform = `translate(${Math.random()*6-3}px, ${Math.random()*6-3}px)`;
        setTimeout(() => el.style.transform = 'none', 50);
    }

    /**
     * Flashes the screen with a color.
     * @param {number} color - Hex color.
     */
    flash(color) {
        const fx = document.getElementById('screen-fx');
        fx.style.backgroundColor = '#' + color.toString(16).padStart(6,'0');
        fx.style.opacity = 0.5;
        setTimeout(() => { fx.style.backgroundColor = 'transparent'; fx.style.opacity = 0.6; }, 100);
    }
}

// ============================================================================
// [6] UI MANAGER
// ============================================================================
/**
 * Represents a single UI window.
 */
class UI_Window {
    /**
     * Creates a new UI Window.
     * @param {string} id - HTML ID for the window.
     * @param {Object} rect - Style object defining position and size.
     * @param {string} [title] - Optional title for the header.
     */
    constructor(id, rect, title) {
        this.el = document.createElement('div'); this.el.className = 'pe-window';
        Object.assign(this.el.style, rect);
        if(title) { const h = document.createElement('div'); h.className = 'pe-header'; h.innerText = title; this.el.appendChild(h); }
        this.content = document.createElement('div'); this.content.className = 'pe-content';
        this.el.appendChild(this.content); document.getElementById('ui-root').appendChild(this.el);
    }

    /**
     * Clears the content of the window.
     */
    clear() { this.content.innerHTML = ''; }
}

/**
 * Manages all UI windows and interactions.
 */
class UIManager {
    /**
     * Creates an instance of UIManager.
     */
    constructor() { this.windows = {}; this.createLayout(); }

    /**
     * Creates the initial UI layout.
     */
    createLayout() {
        this.windows.status = new UI_Window('status', {top:'2%', left:'2%', width:'20%', height:'50%'}, "SQUADRON");
        this.windows.cmd = new UI_Window('cmd', {bottom:'2%', left:'2%', width:'20%', height:'44%'}, "TACTICS");
        this.windows.minimap = new UI_Window('minimap', {top:'2%', right:'2%', width:'20%', height:'0'}, "MINIMAP");
        const mmW = this.windows.minimap.el.clientWidth;
        this.windows.minimap.el.style.height = mmW + 'px';
        const cvs = document.createElement('canvas'); cvs.id = 'minimap-canvas'; cvs.width = 128; cvs.height = 128;
        this.windows.minimap.content.appendChild(cvs);
        this.windows.minimap.content.style.padding = '0';
        this.windows.minimap.content.style.overflow = 'auto';
        
        this.windows.log = new UI_Window('log', {top:`calc(2% + ${mmW + 8}px)`, right:'2%', width:'20%', bottom:'2%'}, "SYSTEM LOG");
        this.windows.view = new UI_Window('view', {top:'2%', left:'23%', width:'54%', height:'96%'}, "OPTICAL FEED");
        this.windows.view.content.id = 'game-view-container';
        this.windows.view.content.style.padding = '0'; 
        this.windows.view.content.style.background = '#000';
        this.windows.view.content.style.display = 'flex';
        this.windows.view.content.style.alignItems = 'center';
        this.windows.view.content.style.justifyContent = 'center';
    }

    /**
     * Refreshes all UI components.
     */
    refresh() { this.refreshStatus(); this.refreshCmd(); this.refreshLog(); this.refreshMinimap(); }

    /**
     * Redraws the minimap.
     */
    refreshMinimap() {
        const c = document.getElementById('minimap-canvas');
        if(!c) return;
        const ts = 4; // Tile Size
        c.width = $gameMap.width * ts;
        c.height = $gameMap.height * ts;
        c.style.width = c.width + "px";
        c.style.height = c.height + "px";

        const ctx = c.getContext('2d');
        ctx.fillStyle = "#000"; ctx.fillRect(0,0,c.width,c.height);

        for(let x=0; x<$gameMap.width; x++) {
            for(let y=0; y<$gameMap.height; y++) {
                if(!$gameMap.visited || !$gameMap.visited[x] || !$gameMap.visited[x][y]) continue;
                const t = $gameMap.tiles[x][y];
                if(t === 1) { ctx.fillStyle = "#444"; ctx.fillRect(x*ts, y*ts, ts, ts); }
                else if(t === 3) { ctx.fillStyle = "#0f0"; ctx.fillRect(x*ts, y*ts, ts, ts); }
                else { ctx.fillStyle = "#222"; ctx.fillRect(x*ts, y*ts, ts, ts); }
            }
        }
        $gameMap.enemies.forEach(e => {
            const dist = Math.abs(e.x - $gameMap.playerX) + Math.abs(e.y - $gameMap.playerY);
            if(dist < 8) {
                ctx.fillStyle = "#f00";
                ctx.shadowColor = "#f00"; ctx.shadowBlur = 4;
                ctx.fillRect(e.x*ts, e.y*ts, ts, ts);
                ctx.shadowBlur = 0;
            }
        });
        ctx.fillStyle = "#0ff"; ctx.fillRect($gameMap.playerX*ts, $gameMap.playerY*ts, ts, ts);

        // Auto scroll to player
        const mm = this.windows.minimap.content;
        const px = $gameMap.playerX * ts;
        const py = $gameMap.playerY * ts;
        mm.scrollTop = py - mm.clientHeight / 2;
        mm.scrollLeft = px - mm.clientWidth / 2;
    }

    /**
     * Refreshes the squad status window.
     */
    refreshStatus() {
        const w = this.windows.status; w.clear();
        $gameParty.members.forEach((m, i) => {
            const active = i === $gameParty.index;
            const div = document.createElement('div'); div.className = `party-slot ${active ? 'active' : ''}`;
            div.onclick = () => { if(!$gameSystem.isBusy && !$gameSystem.isInputBlocked) this.showStatusModal(m); };
            const pct = (m.hp / m.mhp) * 100;
            const pePct = (m.pe / m.mpe) * 100;
            const expPct = (m.exp / m.nextExp) * 100;
            const clr = pct < 30 ? 'var(--pe-red)' : pct < 60 ? 'var(--pe-gold)' : 'var(--pe-green)';
            div.innerHTML = `<div style="color:#${m.color.toString(16)}; width:20px; font-weight:bold;">${m.name[0]}</div>
                <div style="flex:1;">
                    <div style="display:flex; justify-content:space-between;"><span>${m.name}</span><span style="color:${clr}">${m.hp}/${m.mhp}</span></div>
                    <div style="height:4px; bg:#333; margin-top:2px;"><div style="width:${pct}%; height:100%; background:${clr};"></div></div>
                    <div style="height:2px; bg:#222; margin-top:2px;"><div style="width:${pePct}%; height:100%; background:var(--pe-cyan);"></div></div>
                    <div style="height:1px; bg:#111; margin-top:2px; width:100%; display:flex;"><div style="width:${expPct}%; height:100%; background:#888;"></div></div>
                </div>`;
            w.content.appendChild(div);
        });
    }

    /**
     * Refreshes the command window.
     */
    refreshCmd() {
        const w = this.windows.cmd; w.clear();
        const actor = $gameParty.active();
        const btn = (t, s, cb, dis, sk) => {
            const b = document.createElement('div'); b.className = `cmd-btn ${dis?'disabled':''}`;
            b.innerHTML = `<span>${t}</span><span style="font-size:10px; color:#666;">${s}</span>`;
            b.onclick = () => { if(!$gameSystem.isBusy && !$gameSystem.isInputBlocked && !dis) cb(); };
            if(sk) {
                b.onmouseenter = (e) => { Renderer.showRange(sk); this.showTooltip(e, `<b>${sk.name}</b><br>${sk.desc(actor)}`); };
                b.onmouseleave = () => { Renderer.clearRange(); this.hideTooltip(); };
            }
            w.content.appendChild(b);
        };
        btn("WAIT", "", () => $gameMap.processTurn(0,0));
        btn("ITEM", "", () => this.showInventoryModal());
        w.content.appendChild(document.createElement('hr'));
        actor.skills.forEach(k => {
            const s = $dataSkills[k];
            btn(s.name, `${s.cost}PE`, () => {
                if(!$gameSystem.isBusy) $gameMap.processTurn(0,0,()=>BattleManager.executeSkill(actor, k));
                BattleManager.executeSkill(actor, k);
            }, actor.pe < s.cost, s);
        });
    }

    /**
     * Shows a tooltip.
     * @param {Event} e - The mouse event.
     * @param {string} html - HTML content for tooltip.
     */
    showTooltip(e, html) {
        const el = document.getElementById('tooltip'); el.innerHTML = html; el.style.display = 'block';
        el.style.left = (e.clientX + 10) + 'px'; el.style.top = (e.clientY) + 'px';
    }

    /**
     * Hides the tooltip.
     */
    hideTooltip() { document.getElementById('tooltip').style.display = 'none'; }

    /**
     * Refreshes the system log window.
     */
    refreshLog() {
        const w = this.windows.log; w.clear();
        const h = w.content.clientHeight;
        const lineH = 16; 
        const lines = Math.floor(h / lineH) - 1;
        $gameSystem.logHistory.slice(0,lines).forEach((t,i) => {
            const d = document.createElement('div'); d.innerText = `> ${t}`;
            d.style.opacity = 1 - i*0.1; d.style.marginBottom='4px'; if(i===0) d.style.color='#fff';
            w.content.appendChild(d);
        });
    }

    /**
     * Displays floating text at a screen location.
     * @param {string|number} t - The text to display.
     * @param {number} x - The map x coordinate.
     * @param {number} y - The map y coordinate.
     * @param {string} c - CSS color string.
     */
    floatText(t, x, y, c) {
        const pos = Renderer.projectToScreen(x, 0.5, y);
        const container = document.createElement('div');
        container.className = 'float-text-container';
        container.style.left = pos.x + 'px'; 
        container.style.top = pos.y + 'px';
        const chars = t.toString().split('');
        chars.forEach((char, i) => {
            const s = document.createElement('span');
            s.className = 'float-digit';
            s.style.animationDelay = (i * 30) + 'ms';
            s.style.color = c;
            s.innerText = char;
            container.appendChild(s);
        });
        document.getElementById('floating-text-layer').appendChild(container);
        setTimeout(()=>container.remove(), 1200);
    }

    /**
     * Shows the inventory modal window.
     */
    showInventoryModal() {
        $gameSystem.isInputBlocked = true;
        const render = (c) => {
            c.innerHTML = '';
            c.style.display = "flex"; c.style.flexDirection = "column"; c.style.gap = "10px"; c.style.height = "100%";
            const desc = document.createElement('div');
            desc.style.height = "60px"; desc.style.borderBottom = "1px solid #444"; desc.style.marginBottom = "5px"; desc.style.padding = "5px"; desc.style.fontSize = "12px"; desc.style.color = "#aaa"; desc.style.fontStyle = "italic";
            desc.innerText = "Select an item...";
            c.appendChild(desc);
            const body = document.createElement('div');
            body.style.flex = "1"; body.style.display = "flex"; body.style.gap = "10px"; body.style.overflow = "hidden";
            const leftCol = document.createElement('div');
            leftCol.style.flex = "1"; leftCol.style.borderRight = "1px solid #444"; leftCol.style.paddingRight = "5px"; leftCol.style.overflowY = "auto";
            if($gameParty.inventory.length === 0) leftCol.innerHTML = "<div style='color:#666; text-align:center; padding-top:20px;'>Empty</div>";
            $gameParty.inventory.forEach((i, idx) => {
                const r = document.createElement('div'); r.className = 'item-row';
                r.innerHTML = `<span>${i.icon} ${i.name}</span><span style="font-size:10px;color:#666">${i.category.toUpperCase()}</span>`;
                r.onmouseenter = () => desc.innerText = i.desc || "No description.";
                r.onclick = () => { 
                    if(i.category === 'item') {
                        this.showTargetSelectModal((t) => {
                            this.showConfirmModal(`Use ${i.name} on ${t.name}?`, () => this.useConsumable(t, i, idx));
                        });
                    } else {
                        this.showTargetSelectModal((t) => { this.equipGear(t, i, idx, () => { render(c); this.refresh(); }); }, i);
                    }
                };
                leftCol.appendChild(r);
            });
            const rightCol = document.createElement('div');
            rightCol.style.flex = "1"; rightCol.style.display = "flex"; rightCol.style.flexDirection = "column"; rightCol.style.gap = "5px"; rightCol.style.overflowY = "auto";
            rightCol.innerHTML = "<div style='text-align:center; color:var(--pe-gold); font-size:10px; margin-bottom:5px;'>SQUAD STATUS</div>";
            $gameParty.members.forEach(m => {
                const box = document.createElement('div');
                box.style.border = "1px solid #333"; box.style.padding = "4px";
                box.innerHTML = `<div style="font-weight:bold; color:#${m.color.toString(16)}; border-bottom:1px solid #222; margin-bottom:2px; display:flex; justify-content:space-between;"><span>${m.name}</span><span style="font-size:9px; color:#999">ATK:${m.getAtk()} DEF:${m.getDef()}</span></div>`;
                const renderEquip = (slot, item) => {
                    const row = document.createElement('div');
                    row.style.fontSize = "10px"; row.style.display = "flex"; row.style.justifyContent = "space-between";
                    row.style.cursor = item ? "pointer" : "default";
                    if(item) {
                        row.innerHTML = `<span>${slot}: ${item.icon} ${item.name}</span>`;
                        row.onclick = () => {
                            if($gameParty.inventory.length < $gameParty.maxInventory) {
                                $gameParty.gainItem(item); m.equip[slot] = null; render(c); this.refresh();
                            } else { alert("Inventory Full!"); }
                        };
                        row.onmouseover = () => row.style.color = "var(--pe-red)"; row.onmouseout = () => row.style.color = "";
                    } else { row.innerHTML = `<span style="color:#444">${slot}: ---</span>`; }
                    return row;
                };
                box.appendChild(renderEquip('weapon', m.equip.weapon)); box.appendChild(renderEquip('armor', m.equip.armor)); rightCol.appendChild(box);
            });
            body.appendChild(leftCol); body.appendChild(rightCol);
            c.appendChild(body);
        };
        this.createModal(`SHARED INVENTORY [${$gameParty.inventory.length}/${$gameParty.maxInventory}]`, render, () => $gameSystem.isInputBlocked=false);
    }

    /**
     * Uses a consumable item on a target.
     * @param {Game_Actor} actor - The target actor.
     * @param {Game_Item} i - The item to use.
     * @param {number} idx - The index of the item in inventory.
     */
    useConsumable(actor, i, idx) {
        if(i.type==='heal') { actor.heal(i.val); $gameSystem.log(`Healed ${actor.name} for ${i.val}.`); }
        if(i.type==='pe') { actor.pe = Math.min(actor.mpe, actor.pe+i.val); $gameSystem.log(`Restored PE for ${actor.name}.`); }
        if(i.type==='cure') {
            if(actor.isStateAffected('poison')) {
                actor.removeState('poison');
                $gameSystem.log(`${actor.name} is cured.`);
            } else {
                $gameSystem.log("No effect.");
            }
        }
        $gameParty.inventory.splice(idx, 1);
        this.closeModal(); $gameSystem.isInputBlocked = false; this.refresh(); $gameMap.processTurn(0,0);
    }

    /**
     * Equips gear to an actor.
     * @param {Game_Actor} actor - The target actor.
     * @param {Game_Weapon|Game_Armor} i - The item to equip.
     * @param {number} idx - The index of the item in inventory.
     * @param {Function} cb - Callback to run after equipping.
     */
    equipGear(actor, i, idx, cb) {
        const type = i.category; const current = actor.equip[type];
        actor.equip[type] = i; $gameParty.inventory.splice(idx, 1);
        if(current) $gameParty.gainItem(current);
        $gameSystem.log(`${actor.name} equipped ${i.name}.`);
        cb();
    }

    /**
     * Shows a modal to select a target for an item or skill.
     * @param {Function} callback - Function called with selected actor.
     * @param {Object} [itemPreview] - Optional item for stats preview.
     */
    showTargetSelectModal(callback, itemPreview = null) {
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute'; overlay.style.top = '20%'; overlay.style.left = '30%'; overlay.style.width = '40%'; overlay.style.background = 'var(--pe-panel-bg)'; overlay.style.border = '1px solid #444'; overlay.style.zIndex = '150'; overlay.style.padding = '10px';
        overlay.innerHTML = "<div style='color:white; text-align:center; margin-bottom:10px;'>SELECT TARGET</div>";
        $gameParty.members.forEach(m => {
            const btn = document.createElement('div');
            let txt = m.name;
            if(itemPreview) {
                if(itemPreview.category === 'weapon') {
                    const currentAtk = m.getAtk(); const newAtk = m.getAtkWith(itemPreview); const diff = newAtk - currentAtk;
                    const color = diff > 0 ? '#0f0' : (diff < 0 ? '#f00' : '#888');
                    txt += ` (ATK: ${currentAtk} -> <span style='color:${color}'>${newAtk}</span>)`;
                } else if(itemPreview.category === 'armor') {
                    const currentDef = m.getDef(); const newDef = m.getDefWith(itemPreview); const diff = newDef - currentDef;
                    const color = diff > 0 ? '#0f0' : (diff < 0 ? '#f00' : '#888');
                    txt += ` (DEF: ${currentDef} -> <span style='color:${color}'>${newDef}</span>)`;
                }
            }
            btn.innerHTML = txt;
            btn.style.padding = '5px'; btn.style.border = '1px solid #333'; btn.style.marginBottom = '5px'; btn.style.cursor = 'pointer'; btn.style.color = '#'+m.color.toString(16);
            btn.onmouseover = () => btn.style.background = '#333'; btn.onmouseout = () => btn.style.background = '';
            btn.onclick = () => { callback(m); overlay.remove(); };
            overlay.appendChild(btn);
        });
        const cancel = document.createElement('div');
        cancel.innerText = "CANCEL"; cancel.style.color = "#888"; cancel.style.textAlign = "center"; cancel.style.cursor = "pointer"; cancel.style.fontSize = "10px";
        cancel.onclick = () => overlay.remove();
        overlay.appendChild(cancel);
        document.getElementById('ui-root').appendChild(overlay);
    }

    /**
     * Shows a confirmation modal.
     * @param {string} text - The prompt text.
     * @param {Function} onConfirm - Callback if confirmed.
     */
    showConfirmModal(text, onConfirm) {
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute'; overlay.style.top = '40%'; overlay.style.left = '35%'; overlay.style.width = '30%'; overlay.style.background = 'var(--pe-panel-bg)'; overlay.style.border = '1px solid #444'; overlay.style.zIndex = '160'; overlay.style.padding = '10px'; overlay.style.textAlign = 'center';
        overlay.innerHTML = `<div style='color:white; margin-bottom:10px;'>${text}</div>`;
        const yes = document.createElement('button'); yes.innerText = "YES"; yes.className = "cmd-btn"; yes.style.display = "inline-block"; yes.style.width = "40%"; yes.style.marginRight = "10px";
        yes.onclick = () => { onConfirm(); overlay.remove(); };
        const no = document.createElement('button'); no.innerText = "NO"; no.className = "cmd-btn"; no.style.display = "inline-block"; no.style.width = "40%";
        no.onclick = () => overlay.remove();
        overlay.appendChild(yes); overlay.appendChild(no);
        document.getElementById('ui-root').appendChild(overlay);
    }

    /**
     * Shows a modal with actor status details.
     * @param {Game_Actor} a - The actor to show.
     */
    showStatusModal(a) {
        $gameSystem.isInputBlocked = true;
        this.createModal(`STATUS: ${a.name}`, (c) => {
            c.innerHTML = `<div style="display:flex; gap:10px; margin-bottom:10px;">
                <div style="width:60px; height:60px; border:1px solid #444; display:flex; align-items:center; justify-content:center; font-size:30px; color:#${a.color.toString(16)}">${a.name[0]}</div>
                <div style="flex:1"><div class="stat-label">JOB: <span class="stat-val">${a.job}</span></div>
                <div class="stat-label">HP: <span class="stat-val" style="color:var(--pe-green)">${a.hp}/${a.mhp}</span></div>
                <div class="stat-label">PE: <span class="stat-val" style="color:var(--pe-red)">${a.pe}/${a.mpe}</span></div></div></div>
                <hr style="border-color:#333; margin:10px 0;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px;">
                <div><div class="stat-label">ATK</div><div style="color:white">${a.getAtk()}</div></div>
                <div><div class="stat-label">DEF</div><div style="color:white">${a.getDef()}</div></div>
                <div><div class="stat-label">EXP</div><div style="color:white">${a.exp}/${a.nextExp}</div></div>
                <div><div class="stat-label">LVL</div><div style="color:white">${a.level}</div></div></div>`;
        }, () => $gameSystem.isInputBlocked=false);
    }

    /**
     * Creates a generic modal window.
     * @param {string} t - Title of the modal.
     * @param {Function} build - Function to build content into the provided element.
     * @param {Function} close - Callback when modal is closed.
     */
    createModal(t, build, close) {
        if(document.getElementById('temp-modal')) document.getElementById('temp-modal').remove();
        const m = document.createElement('div'); m.id='temp-modal'; m.className='pe-window';
        Object.assign(m.style, {left:'20%', top:'10%', width:'60%', height:'80%', zIndex:100});
        m.innerHTML = `<div class="pe-header" style="display:flex; justify-content:space-between;">${t}<span style="cursor:pointer" id="modal-close">X</span></div><div class="pe-content"></div>`;
        build(m.querySelector('.pe-content'));
        document.getElementById('ui-root').appendChild(m);
        m.querySelector('#modal-close').onclick = () => { this.closeModal(); if(close) close(); };
    }

    /**
     * Closes the temporary modal window.
     */
    closeModal() { if(document.getElementById('temp-modal')) document.getElementById('temp-modal').remove(); }
}

let $gameSystem, $gameParty, $gameMap, Renderer, UI, Cutscene;
/**
 * Static class that manages the main game loop and initialization.
 */
class SceneManager {
    /**
     * Initializes the game.
     */
    static init() {
        $gameSystem = new Game_System(); $gameParty = new Game_Party(); $gameMap = new Game_Map();
        UI = new UIManager(); Renderer = new Renderer3D(); Cutscene = new CutsceneManager();
        Renderer.init(UI.windows.view.content); $gameMap.setup(1); UI.refresh();
        $gameSystem.log("System initialized.");
        
        // INPUT POLLING
        this.keys = {};
        document.addEventListener('keydown', e => this.keys[e.key] = true);
        document.addEventListener('keyup', e => this.keys[e.key] = false);
        
        this.loop();
    }

    /**
     * Main game loop.
     */
    static loop() {
        requestAnimationFrame(() => this.loop());
        // Input Logic
        if (!$gameSystem.isBusy && !$gameSystem.isInputBlocked && !Renderer.isAnimating) {
             if(this.keys["ArrowUp"]||this.keys["w"]) $gameMap.processTurn(0,-1);
             else if(this.keys["ArrowDown"]||this.keys["s"]) $gameMap.processTurn(0,1);
             else if(this.keys["ArrowLeft"]||this.keys["a"]) $gameMap.processTurn(-1,0);
             else if(this.keys["ArrowRight"]||this.keys["d"]) $gameMap.processTurn(1,0);
             else if(this.keys[" "]) $gameMap.processTurn(0,0);
             else if(this.keys["Enter"]) $gameMap.playerAttack();
        }
    }

    /**
     * Triggers game over state.
     */
    static gameOver() { alert("FAILURE."); location.reload(); }
}
window.onload = () => {
    SceneManager.init();

    // Auto-scale to fit window
    const resizeGame = () => {
        const app = document.getElementById('app-container');
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const scale = Math.min(winW / 960, winH / 540);
        app.style.transform = `scale(${scale})`;
    };
    window.addEventListener('resize', resizeGame);
    resizeGame();
};
</script>
</body>
</html>