# Architectural Analysis: Stillnight - Eve of the Stack

**Version:** 2.0
**Status:** Live / Refactored
**Scope:** Full Engine Documentation

---

## 1. Executive Summary

"Stillnight: Eve of the Stack" is a browser-based, turn-based RPG engine built on a modular, event-driven architecture. While it pays homage to classic engines like RPG Maker in its data structures and terminology, it modernizes the implementation through a decoupled Logic/View separation, a Component-based UI framework, and a 3D rendering pipeline powered by Three.js.

The engine runs entirely client-side without a build step, relying on native ES6 class structures and ordered script loading. This document serves as the comprehensive technical manual for the engine's architecture, subsystems, and design philosophies.

---

## 2. Foundational Philosophies

The architecture is guided by several key principles, inferred from the codebase structure:

### 2.1. "Logic-First, View-Second" (Decoupling)
The core game logic (`src/objects.js`, `src/managers.js`) is strictly forbidden from directly manipulating the DOM or the 3D scene.
*   **The Rule:** Logic calculates state; View visualizes state.
*   **The Mechanism:** The `EventBus` (`src/core.js`) acts as the bridge. Logic emits events (`targets_updated`, `log_updated`), and the View subscribers (`Renderer3D`, `UIManager`) react.
*   **Benefit:** This allows the game to run headless (theoretically) or swap rendering engines without rewriting gameplay code.

### 2.2. Pragmatic Global State
Unlike strict functional programming paradigms, the engine embraces global state for its primary runtime containers, a pattern familiar to RPG Maker developers.
*   **Global Singletons:** `$gameSystem`, `$gameParty`, `$gameMap`, `$gameBanter` are globally accessible.
*   **Justification:** In a single-player RPG, these systems *are* effectively singletons. Global access simplifies the extensive cross-referencing required by complex RPG mechanics (e.g., a Skill checking Party state while verifying Map geometry).

### 2.3. Data-Driven Design
Hardcoding behavior is minimized in favor of data structures.
*   **AI:** Enemy behavior is defined by `aiConfig` objects (JSON-like), processed by a generic `decideAction` interpreter.
*   **Banter:** Dialogue is managed via a priority queue system driven by configuration objects containing triggers, conditions, and cooldowns.
*   **Map Gen:** Levels are generated by strategies registered in a `GeneratorRegistry`, allowing configuration to dictate the algorithm (`dungeon` vs `cave`).

### 2.4. Dual-Layer User Interface
The engine is currently in a transitional phase regarding its UI architecture:
*   **Legacy:** Imperative, direct DOM manipulation (found in `src/windows.js`).
*   **Modern:** A declarative, Component/Layout-based system (`src/ui/core.js`) enabling reusable UI widgets and flex/grid layouts.

---

## 3. System Architecture: High-Level Overview

The engine follows a variation of the MVC (Model-View-Controller) pattern, adapted for the game loop.

| Layer | Responsibility | Components / Files |
| :--- | :--- | :--- |
| **Data Layer** | Static configuration and assets. | `src/data.js` (Constants, `$data...` objects) |
| **Model (Logic)** | Runtime state and business rules. | `src/objects.js` (`Game_Actor`, `Game_Map`) |
| **Controller** | Flow control and input handling. | `src/managers.js` (`BattleManager`), `src/main.js` (`SceneManager`) |
| **View (Presentation)** | Visual output (3D & 2D). | `src/sprites.js` (Three.js), `src/ui/*` (DOM) |
| **Core Infrastructure** | Utilities and messaging. | `src/core.js` (`EventBus`, `Geometry`) |

---

## 4. Module Breakdown

The code is distributed across `src/` without bundlers. Dependency order is critical.

1.  **`src/data.js`**: Contains static database objects (`$dataEnemies`, `$dataSkills`) and configuration constants.
2.  **`src/core.js`**:
    *   `EventBus`: The pub/sub system.
    *   `Geometry`: Grid math (Line, Cone, Circle).
    *   `ConditionSystem`: Evaluates requirements (e.g., "HP < 50%").
    *   `Sequencer`: Async helpers (`sleep`).
3.  **`src/input.js`**: `InputManager` handles Keyboard/Gamepad mapping and latching.
4.  **`src/managers.js`**:
    *   `BattleManager`: Handles skill execution, damage calculation, and effect application.
    *   `BanterManager`: Manages the narrative priority queue.
    *   `ItemManager`: Handles inventory transactions.
5.  **`src/generators/map_generators.js`**: Contains `GeneratorRegistry` and PCG algorithms (`DungeonGenerator`, `CaveGenerator`).
6.  **`src/objects.js`**: The heart of the simulation.
    *   `Game_System`, `Game_Map`, `Game_Party`.
    *   `Game_Battler` -> `Game_Actor` / `Game_Enemy`.
7.  **`src/sprites.js`**: `Renderer3D` wraps Three.js, managing the scene graph, camera, and converting grid coordinates to 3D space.
8.  **`src/ui/core.js`**: Base classes for the new UI (`UIComponent`, `UIContainer`, `Window_Base`).
9.  **`src/ui/layouts.js`**: Layout strategies (`FlexLayout`, `GridLayout`).
10. **`src/windows.js`**: Contains legacy UI implementations and the `UIManager` orchestration.
11. **`src/main.js`**: The entry point. Initializes globals and runs the `SceneManager.loop`.

---

## 5. Core Systems Deep Dive

### 5.1. The Game Loop & Input Delegation
Managed by `SceneManager` in `src/main.js`.
1.  **Frame Start:** `requestAnimationFrame` triggers the loop.
2.  **System Updates:** `InputManager` and `$gameBanter` update their internal timers/states.
3.  **Input Delegation:**
    *   **Priority 1 (UI):** If `UI.activeModal` or `UI.focusedWindow` is set, input is routed to `UI.updateInput()`. The map is frozen.
    *   **Priority 2 (Map):** If UI is idle, input flows to `$gameMap`.
        *   Movement (`UP`/`DOWN`...) calls `$gameMap.processTurn()`.
        *   Action (`OK`) calls `$gameMap.playerAttack()`.
        *   Menu (`MENU`) calls `UI.focusWindow('tactics')`.

### 5.2. The Event Bus
The `EventBus` (`src/core.js`) allows systems to communicate without strict dependencies.
*   **Key Topics:**
    *   `log_updated`: Emitted by `Game_System.log`. Subscribed by `Window_Log`.
    *   `targets_updated`: Emitted by `Renderer3D` (via mouse/hover logic) or Logic. Subscribed by `Window_EnemyInfo`.
    *   `play_animation`: Emitted by `BattleManager`. Subscribed by `Renderer3D`.
    *   `refresh_ui`: Generic signal to redraw all windows.

### 5.3. 3D Renderer (Three.js Integration)
The `Renderer3D` class acts as a specialized wrapper around Three.js.
*   **Grid Projection:** It maps logical grid coordinates (x, y) to 3D space (x, 0.02, y).
*   **Instanced Rendering:** Used for tiles to ensure performance.
*   **Visual FX:** Handles "juice" like screen shake and flash via CSS overlays, distinct from the WebGL canvas.
*   **Pixelation:** The renderer uses a viewport strategy (rendering at low res, scaling up via CSS) to enforce a retro pixel-art aesthetic.

### 5.4. Dual UI Architecture
The engine contains two distinct UI generations:
*   **Generation 1 (Legacy):** `src/windows.js`. Uses direct `innerHTML` replacement and hardcoded logic.
    *   *Example:* `Window_Target`, `Window_Confirm`.
*   **Generation 2 (Component):** `src/ui/`. Uses a tree of `UIComponent` instances managed by Layouts.
    *   *Example:* `Window_Party`, `Window_Status`.
    *   *Structure:* Components defined in blueprints (JSON) are recursively built into DOM elements. `Window_Base` manages the lifecycle (Refresh -> Build -> Mount).

---

## 6. Game Logic Deep Dive

### 6.1. Entity Hierarchy
*   **`Game_Battler`:** Base class for all combatants. Handles HP, States, Traits (`paramPlus`, `paramRate`).
*   **`Game_Actor`:** Adds Party-specific logic (Stamina, Experience, Inventory reference).
*   **`Game_Enemy`:** Adds AI logic and Drop tables.

### 6.2. The Turn System
The game uses a "Phase-less" turn system initiated by player action.
1.  **Player Input:** Logic verifies validity (e.g., not blocked by wall).
2.  **Player Action:** Move or Attack is executed immediately.
3.  **Enemy Turn:** `Game_Map.updateEnemies()` iterates through all enemies.
    *   Each enemy calls `decideAction()`.
    *   Actions are executed sequentially (mostly).
4.  **End of Turn:** `processTurnEnd` ticks states, regeneration, and cooldowns.

### 6.3. AI & Behavior
Enemy AI is data-driven via `aiConfig` in `$dataEnemies`.
*   **Structure:** List of actions with `condition`, `skillId`, and `rating`.
*   **Evaluation:** The `Game_Enemy.decideAction` method evaluates conditions (using `ConditionSystem`) and picks the best valid action.
*   **Fallback:** If no config exists, it defaults to legacy behaviors (Hunter/Patrol).

---

## 7. Subsystems

### 7.1. Procedural Map Generation
Located in `src/generators/map_generators.js`.
*   **Registry:** `$generatorRegistry` maps floor types (e.g., 'dungeon') to Generator classes.
*   **Algorithms:**
    *   `DungeonGenerator`: BSP-based room and corridor generation.
    *   `CaveGenerator`: Cellular Automata for organic shapes.
*   **Output:** Returns a simplified data object (`tiles`, `rooms`, `startPos`) which `Game_Map.setup` inflates into the live map.

### 7.2. Banter System
A narrative layer that runs asynchronously to gameplay.
*   **Queue:** A priority queue manages incoming dialogue requests.
*   **Cooldowns:** Global, Trigger-based, and Actor-based cooldowns prevent spam.
*   **Chaining:** Support for `reply` properties allows for multi-actor conversations.

---

## 8. Technical Debt & Inconsistencies

While the architecture is robust, several inconsistencies remain:
1.  **UI Fragmentation:** The coexistence of Legacy and Component UI requires developers to know two different systems.
2.  **Global Pollution:** The lack of ES Modules means global namespace pollution is high. Naming conventions (`$game...`) are the only protection.
3.  **Input Handling:** Input logic is split between `InputManager` (hardware abstraction) and `SceneManager` (contextual delegation), with some direct checks in `Game_Map`.
4.  **Geometry Duplication:** Some visibility/targeting logic appears in both `Geometry` class and `Game_Map` methods.

---
